/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdlib.h>
#include "main.h"

#define 	S1_FLAG 	0x01
#define 	S2_FLAG 	0x02
#define 	S3_FLAG 	0x04
#define		SW_INIT		0x08
#define 	SW_COUNT	0x10
#define     SW_LAP      0X20

void Sx_Flags_Update(uint8_t *sx_flags);
void Dx_Update(uint8_t flags);
void FSM_Increase_every_10ms(uint32_t *time_10ms);
void FSM_Stop_Watch(uint8_t *sx_flags);

/*uint8_t* itoa(uint32_t value, uint8_t* buffer, uint8_t base);
void swap(uint8_t *x, uint8_t *y);
uint8_t* reverse(uint8_t *buffer, uint32_t i, uint32_t j);*/
extern char *	utoa (unsigned, char *, int);
void process_string(uint8_t *buffer);
extern int	abs (int);
int main(void)
{
	LL_Init1msTick(4000000);

	Sx_Init();
	Dx_Init();
	Display_Init();

	Keypad_Init();

	uint8_t msg[5]="____";
	uint8_t lap_update =0;
	uint32_t time = 0,lap_time;
	uint8_t flags=0;
	/* Loop forever */
	for(;;){
		FSM_D4_Blink();

		/*S1_Scan() ? D1_On():D1_Off();
		S2_Scan() ? D2_On():D2_Off();
		S3_Scan() ? D3_On():D3_Off();*/
		Sx_Flags_Update(&flags);
		uint8_t input = Keypad_Scan();

		msg[3] = (input == 0) ? '_' :  input;

		FSM_Stop_Watch(&flags);

		if (flags & SW_INIT){
			flags &= ~SW_INIT;
			time = 0;
		}
		if (flags & SW_COUNT){
			FSM_Increase_every_10ms(&time);
		}

		if (flags & SW_LAP){
			if (lap_update==0){
				lap_time = time;
				lap_update = 1;
			}
			utoa((unsigned) lap_time, (char *) msg, 10);
		}else{
			lap_update=0;
			utoa((unsigned) time, (char *) msg, 10);
		}

		if (flags & SW_LAP){
			flags &= ~SW_LAP;
			lap_time = time;
		}

		process_string(msg);

		Dx_Update(flags);

		FSM_Write_D4(msg);
	}
}



void Sx_Flags_Update(uint8_t *sx_flags){
	static uint32_t last_tick = 0;
	uint32_t current_tick;
	static uint8_t s1_state = 0,s2_state = 0,s3_state = 0;


	current_tick = Get_Tick();
	if (current_tick-last_tick >= 10){
		last_tick = current_tick;


		switch(s1_state){
		case 0:
			if (S1_Scan())
				s1_state = 1;

			break;
		case 1:
			if (!S1_Scan()){
				s1_state = 0;
				*sx_flags ^= S1_FLAG;
			}
			break;
		}

		switch(s2_state){
		case 0:
			if (S2_Scan())
				s2_state = 1;

			break;
		case 1:
			if (!S2_Scan()){
				s2_state = 0;
				*sx_flags ^= S2_FLAG;
			}
			break;
		}
		switch(s3_state){
		case 0:
			if (S3_Scan())
				s3_state = 1;

			break;
		case 1:
			if (!S3_Scan()){
				s3_state = 0;
				*sx_flags ^= S3_FLAG;
			}
			break;
		}

	}
}

void Dx_Update(uint8_t flags){
	(flags & 1) ? D1_On() : D1_Off();
	(flags & (1<<1)) ? D2_On() : D2_Off();
	(flags & (1<<2)) ? D3_On() : D3_Off();
}
void FSM_Increase_every_10ms(uint32_t *time_10ms){
	static uint32_t last_tick = 0;
	uint32_t current_tick;

	current_tick = Get_Tick();
	if (current_tick-last_tick >= 10){
		last_tick = current_tick;
		*time_10ms += 1;
	}
}

enum sw_state_t {INIT,RUN,PAUSE,LAP};
void FSM_Stop_Watch(uint8_t *flags){
	static uint32_t last_tick = 0;
	uint32_t current_tick;
	static enum sw_state_t sw_state = INIT;


	current_tick = Get_Tick();
	if (current_tick-last_tick >= 100){
		last_tick = current_tick;

		switch(sw_state){
		case INIT:
			if (*flags & S1_FLAG){
				*flags ^= S1_FLAG;
				sw_state = RUN;
				*flags |= SW_COUNT;
			}
			break;
		case RUN:
			if (*flags & S2_FLAG){
				*flags ^= S2_FLAG;
				sw_state = PAUSE;
				*flags &= ~SW_COUNT;
			}
			if (*flags & S3_FLAG){
				*flags ^= S3_FLAG;
				sw_state = LAP;
				*flags |= SW_LAP;
			}
			break;

		case PAUSE:
			if (*flags & S1_FLAG){
				*flags ^= S1_FLAG;
				sw_state = RUN;
				*flags |= SW_COUNT;
			}
			if (*flags & S2_FLAG){
				*flags ^= S2_FLAG;
				sw_state = INIT;
				*flags &= ~SW_COUNT;
				*flags |= SW_INIT;
			}
			break;
		case LAP:
					if (*flags & S1_FLAG){
						*flags ^= S1_FLAG;
						sw_state = RUN;
						*flags &= ~SW_LAP;
					}
					break;
		}
	}
}

/*uint8_t* itoa(uint32_t value, uint8_t* buffer, uint8_t base)
{
	// invalid input
	if (base < 2 || base > 32) {
		return 0;
	}

	// consider the absolute value of the number
	int n = abs((int)value);

	int i = 0;
	while (n)
	{
		int r = n % base;

		if (r >= 10) {
			buffer[i++] = 65 + (r - 10);
		}
		else {
			buffer[i++] = 48 + r;
		}

		n = n / base;
	}

	// if the number is 0
	if (i == 0) {
		buffer[i++] = '0';
	}

	// If the base is 10 and the value is negative, the resulting string
	// is preceded with a minus sign (-)
	// With any other base, value is always considered unsigned
	if (value < 0 && base == 10) {
		buffer[i++] = '-';
	}

	buffer[i] = '\0'; // null terminate string

	// reverse the string and return it
	return reverse(buffer, 0, i - 1);
}

void swap(uint8_t *x, uint8_t *y) {
	uint8_t t = *x; *x = *y; *y = t;
}

// Function to reverse `buffer[iâ€¦j]`
uint8_t* reverse(uint8_t *buffer, uint32_t i, uint32_t j)
{
	while (i < j) {
		swap(&buffer[i++], &buffer[j--]);
	}

	return buffer;
}*/

void process_string(uint8_t *buffer){
	uint8_t i = 0;
	while (i<4){
		if (buffer[i] == '\0'){
			break;
		}
		i++;
	}
	if (i<4){
		for (int j=0;j<=i;j++){
			buffer[4-j]=buffer[i-j];
		}
		for (int j=0;j<4-i;j++){
			buffer[j]='=';
		}
	}

}


